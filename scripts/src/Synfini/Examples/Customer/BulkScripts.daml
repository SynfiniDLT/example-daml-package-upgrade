-- Copyright (c) 2023 ASX Operations Pty Ltd. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE ApplicativeDo #-}

module Synfini.Examples.Customer.BulkScripts (
  CustomerPopulation(..),
  CustomerPopulation_ArchiveBulk(..),
  CustomerPopulation_GenerateBulk(..),
  BulkInput(..),
  generateBulk,
  upgradeBulk,
  archiveBulk
) where

import qualified DA.Action as A
import qualified DA.Foldable as F
import DA.Time (RelTime)
import Daml.Script
import Synfini.Examples.Customer.Upgrade
import qualified Synfini.Examples.Customer.V1 as V1
import qualified Synfini.Examples.Customer.V2 as V2

identifier : Text -> Int -> Text
identifier entropy index = entropy <> "-" <> show index

genContract : Party -> Text -> Int -> Update ()
genContract operator entropy index = do
  let id = identifier entropy index
  let favouriteColour = case index % 3 of
        0 -> V1.Red
        1 -> V1.Green
        2 -> V1.Blue
  create V1.Customer with operator, id, name = "Test customer " <> show index, favouriteColour
  pure ()

archiveContract : Party -> Text -> Int -> Update ()
archiveContract operator entropy index = do
  let id = identifier entropy index
  let k1 = V1.CustomerKey with operator, id
      k2 = V2.CustomerKey with operator, id
  customerCidOpt1 <- lookupByKey @V1.Customer k1
  F.forA_ customerCidOpt1 archive
  customerCidOpt2 <- lookupByKey @V2.Customer k2
  F.forA_ customerCidOpt2 archive

template CustomerPopulation
  with
    operator : Party
  where
    signatory operator

    key operator : Party
    maintainer key

    nonconsuming choice CustomerPopulation_GenerateBulk : ()
      with
        entropy : Text
        startIndex : Int
        endIndex : Int
      controller operator
      do
        F.mapA_ (genContract operator entropy) [startIndex..endIndex]

    nonconsuming choice CustomerPopulation_ArchiveBulk : ()
      with
        entropy : Text
        startIndex : Int
        endIndex : Int
      controller operator
      do
        F.mapA_ (archiveContract operator entropy) [startIndex..endIndex]

createSetupContracts : Party -> Script ()
createSetupContracts operator = do
  populationContracts <- query @CustomerPopulation operator
  A.when (null populationContracts) do
    A.void $ submit operator do createCmd CustomerPopulation with operator
  upgradeContracts <- query @CustomerUpgrade operator
  A.when (null upgradeContracts) do
    A.void $ submit operator do createCmd CustomerUpgrade with operator

data BulkInput = BulkInput
  with
    operator : Party
    entropy : Text
    numContracts : Int
    batchSize : Int
    sleepTime : Optional RelTime
  deriving (Show, Eq)

exerciseGenBulk : BulkInput -> Int -> Script ()
exerciseGenBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  submit input.operator do
    exerciseByKeyCmd @CustomerPopulation input.operator CustomerPopulation_GenerateBulk with
      entropy = input.entropy
      startIndex
      endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1

generateBulk : BulkInput -> Script ()
generateBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseGenBulk input) [0,input.batchSize..input.numContracts - 1]

exerciseUpgradeBulk : BulkInput -> Int -> Script ()
exerciseUpgradeBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  let endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1
  submit input.operator do
    exerciseByKeyCmd @CustomerUpgrade input.operator CustomerUpgrade_BatchUpgrade with
      ids = (identifier input.entropy) <$> [startIndex..endIndex]

upgradeBulk : BulkInput -> Script ()
upgradeBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseUpgradeBulk input) [0,input.batchSize..input.numContracts - 1]

exerciseArchiveBulk : BulkInput -> Int -> Script ()
exerciseArchiveBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  submit input.operator do
    exerciseByKeyCmd @CustomerPopulation input.operator CustomerPopulation_ArchiveBulk with
      entropy = input.entropy
      startIndex
      endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1

archiveBulk : BulkInput -> Script ()
archiveBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseArchiveBulk input) [0,input.batchSize..input.numContracts - 1]
