-- Copyright (c) 2023 ASX Operations Pty Ltd. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE ApplicativeDo #-}

module Synfini.Examples.Customer.BulkScripts (
  CustomerPopulation(..),
  CustomerPopulation_ArchiveBulk(..),
  CustomerPopulation_GenerateBulk(..),
  BulkInput(..),
  generateBulk,
  generateBulkWithoutKey,
  upgradeBulk,
  upgradeBulkWithoutKey,
  archiveBulk
) where

import qualified DA.Action as A
import qualified DA.Foldable as F
import DA.Time (RelTime)
import Daml.Script
import Synfini.Examples.Customer.Upgrade
import qualified Synfini.Examples.Customer.V1 as V1
import qualified Synfini.Examples.Customer.V2 as V2

identifier : Text -> Int -> Text
identifier entropy index = entropy <> "-" <> show index

genFavouriteColour : Int -> V1.Colour
genFavouriteColour index = case index % 3 of
  0 -> V1.Red
  1 -> V1.Green
  2 -> V1.Blue

genContract : Party -> Text -> Int -> Update ()
genContract operator entropy index = do
  let id = identifier entropy index
  let favouriteColour = genFavouriteColour index
  create V1.Customer with operator, id, name = "Test customer " <> show index, favouriteColour
  pure ()

genContractWithoutKey : Party -> Text -> Int -> Update (ContractId V1.CustomerWithoutKey)
genContractWithoutKey operator entropy index = do
  let id = identifier entropy index
  let favouriteColour = genFavouriteColour index
  create V1.CustomerWithoutKey with operator, id, name = "Test customer " <> show index, favouriteColour

archiveContract : Party -> Text -> Int -> Update ()
archiveContract operator entropy index = do
  let id = identifier entropy index
  let k1 = V1.CustomerKey with operator, id
      k2 = V2.CustomerKey with operator, id
  customerCidOpt1 <- lookupByKey @V1.Customer k1
  F.forA_ customerCidOpt1 archive
  customerCidOpt2 <- lookupByKey @V2.Customer k2
  F.forA_ customerCidOpt2 archive

-- archiveContractWithoutKey : Party -> ContractId V1.CustomerWithoutKey -> Update () 
-- archiveContractWithoutKey operator cid =

template CustomerPopulation
  with
    operator : Party
  where
    signatory operator

    key operator : Party
    maintainer key

    nonconsuming choice CustomerPopulation_GenerateBulk : ()
      with
        entropy : Text
        startIndex : Int
        endIndex : Int
      controller operator
      do
        F.mapA_ (genContract operator entropy) [startIndex..endIndex]

    nonconsuming choice CustomerPopulation_GenerateBulkWithoutKey : [ContractId V1.CustomerWithoutKey]
      with
        entropy : Text
        startIndex : Int
        endIndex : Int
      controller operator
      do
        mapA (genContractWithoutKey operator entropy) [startIndex..endIndex]

    nonconsuming choice CustomerPopulation_ArchiveBulk : ()
      with
        entropy : Text
        startIndex : Int
        endIndex : Int
      controller operator
      do
        F.mapA_ (archiveContract operator entropy) [startIndex..endIndex]

    -- nonconsuming choice CustomerPopulation_ArchiveBulkWithoutKey : ()
    --   with
    --     cids : [ContractId V1.CustomerWithoutKey]
    --   controller operator
    --   do
    --     F.mapA_ archiveContractWithoutKey cids

createSetupContracts : Party -> Script ()
createSetupContracts operator = do
  populationContracts <- query @CustomerPopulation operator
  A.when (null populationContracts) do
    A.void $ submit operator do createCmd CustomerPopulation with operator
  upgradeContracts <- query @CustomerUpgrade operator
  A.when (null upgradeContracts) do
    A.void $ submit operator do createCmd CustomerUpgrade with operator

data BulkInput = BulkInput
  with
    operator : Party
    entropy : Text
    numContracts : Int
    batchSize : Int
    sleepTime : Optional RelTime
  deriving (Show, Eq)

exerciseGenBulk : BulkInput -> Int -> Script ()
exerciseGenBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  submit input.operator do
    exerciseByKeyCmd @CustomerPopulation input.operator CustomerPopulation_GenerateBulk with
      entropy = input.entropy
      startIndex
      endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1

generateBulk : BulkInput -> Script ()
generateBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseGenBulk input) [0,input.batchSize..input.numContracts - 1]

exerciseGenBulkWithoutKey : BulkInput -> Int -> Script [ContractId V1.CustomerWithoutKey]
exerciseGenBulkWithoutKey input startIndex = do
  submit input.operator do
    exerciseByKeyCmd @CustomerPopulation input.operator CustomerPopulation_GenerateBulkWithoutKey with
      entropy = input.entropy
      startIndex
      endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1

generateBulkWithoutKey : BulkInput -> Script UpgradeBulkInputWithoutKey
generateBulkWithoutKey input = do
  createSetupContracts input.operator
  contractIds <- concat <$> mapA (exerciseGenBulkWithoutKey input) [0,input.batchSize..input.numContracts - 1]
  pure UpgradeBulkInputWithoutKey with
    operator = input.operator
    batchSize = input.batchSize
    contractIds

exerciseUpgradeBulk : BulkInput -> Int -> Script ()
exerciseUpgradeBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  let endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1
  submit input.operator do
    exerciseByKeyCmd @CustomerUpgrade input.operator CustomerUpgrade_BatchUpgrade with
      ids = (identifier input.entropy) <$> [startIndex..endIndex]

upgradeBulk : BulkInput -> Script ()
upgradeBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseUpgradeBulk input) [0,input.batchSize..input.numContracts - 1]

data UpgradeBulkInputWithoutKey = UpgradeBulkInputWithoutKey
  with
    operator : Party
    contractIds : [ContractId V1.CustomerWithoutKey]
    batchSize : Int
  deriving (Show, Eq)

exerciseUpgradeBulkWithoutKey : UpgradeBulkInputWithoutKey -> [ContractId V1.CustomerWithoutKey] -> Script ()
exerciseUpgradeBulkWithoutKey _ [] = pure ()
exerciseUpgradeBulkWithoutKey input contractIds = do
  let batch = take input.batchSize contractIds
  submit input.operator do
    exerciseByKeyCmd @CustomerUpgrade input.operator CustomerUpgrade_BatchUpgradeWithoutKey with
      cids = batch
  exerciseUpgradeBulkWithoutKey input (drop input.batchSize contractIds)

upgradeBulkWithoutKey : UpgradeBulkInputWithoutKey -> Script ()
upgradeBulkWithoutKey input = exerciseUpgradeBulkWithoutKey input input.contractIds

exerciseArchiveBulk : BulkInput -> Int -> Script ()
exerciseArchiveBulk input startIndex = do
  F.forA_ input.sleepTime sleep
  submit input.operator do
    exerciseByKeyCmd @CustomerPopulation input.operator CustomerPopulation_ArchiveBulk with
      entropy = input.entropy
      startIndex
      endIndex = (min input.numContracts (startIndex + input.batchSize)) - 1

archiveBulk : BulkInput -> Script ()
archiveBulk input = do
  createSetupContracts input.operator
  F.mapA_ (exerciseArchiveBulk input) [0,input.batchSize..input.numContracts - 1]
